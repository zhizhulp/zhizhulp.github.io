<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Jetpack学习-Lifecycles]]></title>
    <url>%2F2019%2F06%2F03%2FJetpack%E5%AD%A6%E4%B9%A0-Lifecycles%2F</url>
    <content type="text"><![CDATA[Lifecycle为何出现？ 在Activity生命周期方法中例如onCreate()、onStart()、onStop()中有大量的代码，例如一个获取用户位置的组件需要在onCreate()中初始化实例，在onStart()中开始获取用户位置，在onStop()中停止获取用户位置。这只是一个组件，在实际开发当中，业务是复杂的，组件也是很多的，维护这么多组件，会耗费很多精力。 是我们无法预测组件能在onStop()之前开始。例如一个定位组件需要在onStart()中检查配置（耗时操作），然后回调结果，开始获取位置。但是用户按下了home键，此时app进入后台，onStart()收到回调，那么在回调中做一些操作就会很危险（官方翻译 是组件保持活动的时间超过其所需的时间，大概意思是本应该在onStop()中销毁的一些对象，重新在onStart收到回调后复活了）。 如何处理on stop events?Event.ON_STOP 并不是随着Activity生命周期onStop()调用的，而是伴随着Activity生命周期中的onSaveInstanceState()，onStop()是在onSaveInstanceState()后面调用的。下面是demo中的log： 123456789101112131415161718//进入MainActivity2019-06-03 18:29:51.455 9831-9831/com.example.jetpackdemo D/MainActivity_LocationM: onCreate2019-06-03 18:29:51.487 9831-9831/com.example.jetpackdemo D/LocationM: create-CREATED2019-06-03 18:29:51.488 9831-9831/com.example.jetpackdemo D/MainActivity_LocationM: onStart2019-06-03 18:29:51.489 9831-9831/com.example.jetpackdemo D/LocationM: start-STARTED2019-06-03 18:29:51.493 9831-9831/com.example.jetpackdemo D/MainActivity_LocationM: onResume2019-06-03 18:29:51.494 9831-9831/com.example.jetpackdemo D/LocationM: resume-RESUMED//按home键/进入其他页面/按电源键/横竖屏切换（即app短暂进入后台）2019-06-03 18:29:56.099 9831-9831/com.example.jetpackdemo D/LocationM: pause-STARTED2019-06-03 18:29:56.100 9831-9831/com.example.jetpackdemo D/MainActivity_LocationM: onPause2019-06-03 18:29:56.522 9831-9831/com.example.jetpackdemo D/MainActivity_LocationM: onSaveInstanceState2019-06-03 18:29:56.523 9831-9831/com.example.jetpackdemo D/LocationM: stop-CREATED2019-06-03 18:29:56.524 9831-9831/com.example.jetpackdemo D/MainActivity_LocationM: onStop//重新进入MainActivity2019-06-03 18:30:07.496 9831-9831/com.example.jetpackdemo D/MainActivity_LocationM: onStart2019-06-03 18:30:07.497 9831-9831/com.example.jetpackdemo D/LocationM: start-STARTED2019-06-03 18:30:07.497 9831-9831/com.example.jetpackdemo D/MainActivity_LocationM: onResume2019-06-03 18:30:07.500 9831-9831/com.example.jetpackdemo D/LocationM: resume-RESUMED 如何理解State?官方的图解如下: 为什么State只有5个？分别为INITIALIZED、DESTROYED、CREATED、STARTED、RESUMED，这里我参考了 这个博客 （非常感谢），其实这5个状态并不像字面上的意思。 生命周期状态为RESUMED时表示，当前activity 是在前台，并且可交互也就onResume()执行后。 生命周期状态为STARTED时，表示当前activity处于可见但是不可交互，也就是onStart()方法刚执行完或者onPause()方法刚执行完的状态。 生命周期状态为CREATED，表示onCreate()方法刚刚执行完或者onStop()方法刚刚执行完，也就是当前activity不在前台，但是也没有处于销毁状态。 生命周期状态为DESTORYED,表示当前Activity还不存在，没有被创建或者已经销毁，我们通常考虑比较多的就是，onDestory()方法执行后，当前Activity已经销毁。 生命周期状态为INITIALIZED，表示初始状态。 所以，如果我们要保证在Activity/Fragment的有效生命周期内进行的操作，必须判断，当前lifecycle的状态是否至少是CREATED状态，避免Activity或者fragment销毁了以后，回调或者网络请求才回来，此时做一些操作会导致异常。代码如下 123if (lifecycle.currentState.isAtLeast(Lifecycle.State.STARTED)) &#123; // do something 保证数据回调回来，当前activity是存在的，也就是State必须为STARTED、RESUMED， Activity此时的状态应该为onStart、onResume、onPause。 &#125;]]></content>
      <categories>
        <category>Jetpack</category>
      </categories>
      <tags>
        <tag>Android，Jetpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo在Windows下的安装及配置]]></title>
    <url>%2F2019%2F05%2F31%2FHexo%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[安装Git下载git-for-windows ，然后一步一步安装。 安装Node下载node ，然后一步一步安装。 安装Hexo1npm install hexo-cli -g Hexo的初始化123hexo init blogcd blognpm install Hexo的本地测试1hexo s Hexo部署首先在你的github新建一个仓库，名字必须为仓库名.github.io。打开blog根目录下的_config.yml文件，加入或修改成以下配置 1234deploy:type: gitrepo: git@github.com:仓库名/仓库名.github.io.gitbranch: master]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo、Hugo、Jekyll、Ghost的比较]]></title>
    <url>%2F2019%2F05%2F28%2FHexo%E3%80%81Hugo%E3%80%81%20Jekyll%E3%80%81%20Ghost%E5%AF%B9%E6%AF%94%2F</url>
    <content type="text"><![CDATA[Hexo、Hugo、 Jekyll、 Ghost都是生成静态网站的框架。我们先来比较一下：（Github上4个框架的数据来自2019年5月28号） Github star数量 issues(open) issues(close) 语言 多语言 收费 Hexo 26.6k 196 2934 JavaScript 支持 不收 Hugo 35.4k 324 3367 Go 不确定 不收 Jekyll 37.8k 196 1934 Ruby 不确定 不收 Ghost 30.0k 82 5310 JavaScript 不确定 收 从表格可以看出（综合Github star和issues来看） 最活跃的框架是Ghost，没错，因为Ghost是收费的。对于一个只想玩玩的个人开发者来说，我并不建议使用Ghost来搭建个人博客。 Jekyll最受欢迎，并且免费。]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>静态页面生成器</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[欢迎使用Hexo]]></title>
    <url>%2F2019%2F05%2F28%2FHexo%E6%AC%A2%E8%BF%8E%E9%A1%B5%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[欢迎来到 Hexo！ 你可以在 Hexo文档 中获取更多信息。 如果你在使用Hexo过程中遇到任何问题，你可以在故障排除寻找答案，或者你可以在 GitHub寻找答案。 快速开始新建一篇博客1$ hexo new "My New Post" 更多信息请查看: writing 在本地服务中运行1$ hexo server 更多信息请查看: server 生成静态文件1$ hexo generate 更多信息请查看: generating 部署到远程网站1$ hexo deploy 更多信息请查看: deployment]]></content>
  </entry>
</search>
