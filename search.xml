<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[我为什么最终决定要写博客]]></title>
    <url>%2F2019%2F06%2F05%2F%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%80%E7%BB%88%E5%86%B3%E5%AE%9A%E8%A6%81%E5%86%99%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"></content>
      <categories>
        <category>闲谈</category>
      </categories>
      <tags>
        <tag>闲谈</tag>
        <tag>经验</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个高大上的名字-POJO]]></title>
    <url>%2F2019%2F06%2F05%2F%E4%B8%80%E4%B8%AA%E9%AB%98%E5%A4%A7%E4%B8%8A%E7%9A%84%E5%90%8D%E5%AD%97-POJO%2F</url>
    <content type="text"><![CDATA[POJO名字乍一看都会被吓到，但是POJO其实很简单，下面的段落部分摘抄自 这位博主 。 POJO的创始人(martinfowler)博客： The term was coined while Rebecca Parsons, Josh MacKenzie and I were preparing for a talk at a conference in September 2000. In the talk we were pointing out the many benefits of encoding business logic into regular java objects rather than using Entity Beans. We wondered why people were so against using regular objects in their systems and concluded that it was because simple objects lacked a fancy name. So we gave them one, and it’s caught on very nicely.…在谈话中我们指出，编写业务逻辑的时候，使用常规的java对象要比实体bean要好的多。我们怀疑为什么一些人极力反对在他们的代码中使用常规对象，还辩解称因为这些常规对象没有一个花哨的名字，所以我们给他们起了一个非常好听的名字。（Plain Old Java Object） 维基百科原文 The term “POJO” initially denoted a Java object which does not follow any of the major Java object models, conventions, or frameworks; nowadays “POJO” may be used as an acronym for “Plain Old JavaScript Object” as well, in which case the term denotes a JavaScript object of similar pedigree.[2]术语POJO起初表示为不遵任何主要的java模型，约定或者框架的java对象，现在，pojo也可以用作’Plain Old JavaScript Object’的缩写，这样的话和javascript对象有着相似的渊源。 JavaBean维基百科中JavaBeans的概念 A JavaBean is a POJO that is serializable, has a no-argument constructor, and allows access to properties using getter and setter methods that follow a simple naming convention. Because of this convention, simple declarative references can be made to the properties of arbitrary JavaBeans. Code using such a declarative reference does not have to know anything about the type of the bean, and the bean can be used with many frameworks without these frameworks having to know the exact type of the bean. The JavaBeans specification, if fully implemented, slightly breaks the POJO model as the class must implement the Serializable interface to be a true JavaBean. Many POJO classes still called JavaBeans do not meet this requirement. Since Serializable is a marker (method-less) interface, this is not much of a burden.JavaBean是一个可序列化的POJO，具有一个无参构造器，并且允许使用遵循简单命名约定的getter和setter方法来访问属性。由于这个惯例，可以对任意JavaBean属性进行简单的声明引用。使用这种声明引用的代码不需要知道bean的具体类型。并且，这个bean还可以被很多框架使用，这些java框架也不需要知道bean的类型。由于java.io.Serializable是一个标记接口（无方法），所以这并不是一个多大的负担。如果JavaBean完全实现的话，稍微打破了一些POJO模型。很多被称之为JavaBean的POJO类并不符合这个要求，因为JavaBean必须实现Serializable接口才能成为真正的JavaBean。 有些人看上面一堆肯定头疼，不如上点代码： 12345678910111213141516public class POJO &#123; private String name; private String id; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125;&#125; 12345678910111213141516171819 public class JavaBean implements Serializable&#123; private String name; private String id; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public void eat()&#123; System.out.println(name+"吃了满汉全席！"); &#125;&#125; 总结来讲： POJO就是一个只有属性和get、set方法的简单类。 JavaBean在POJO的基础上实现了持久化并且使其拥有了行为。]]></content>
      <categories>
        <category>Jetpack</category>
      </categories>
      <tags>
        <tag>databinding</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jetpack学习-DataBinding]]></title>
    <url>%2F2019%2F06%2F04%2FJetpack%E5%AD%A6%E4%B9%A0-DataBinding%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Jetpack学习-Lifecycles]]></title>
    <url>%2F2019%2F06%2F03%2FJetpack%E5%AD%A6%E4%B9%A0-Lifecycles%2F</url>
    <content type="text"><![CDATA[Lifecycle为何出现？ 在Activity生命周期方法中例如onCreate()、onStart()、onStop()中有大量的代码，例如一个获取用户位置的组件需要在onCreate()中初始化实例，在onStart()中开始获取用户位置，在onStop()中停止获取用户位置。这只是一个组件，在实际开发当中，业务是复杂的，组件也是很多的，维护这么多组件，会耗费很多精力。 是我们无法预测组件能在onStop()之前开始。例如一个定位组件需要在onStart()中检查配置（耗时操作），然后回调结果，开始获取位置。但是用户按下了home键，此时app进入后台，onStart()收到回调，那么在回调中做一些操作就会很危险（官方翻译 是组件保持活动的时间超过其所需的时间，大概意思是本应该在onStop()中销毁的一些对象，重新在onStart收到回调后复活了）。 如何处理on stop events?Event.ON_STOP 并不是随着Activity生命周期onStop()调用的，而是伴随着Activity生命周期中的onSaveInstanceState()，onStop()是在onSaveInstanceState()后面调用的。 在 官方文档 中有这样一个小问题，为了使流程更简单，并与旧版本提供更好的兼容性，从版本1.0.0 RC1开始，Lifecycle对象被标记为CREATED，当onSaveInstanceState()被调用时， ON_STOP事件被分发，而不需等待调用onStop()方法。这不太可能影响您的代码，但这里你需要注意，因为它与API级别26和更低的Activity类中的调用顺序不匹配。所以这里不做详细的研究（之前一直对这里耿耿于怀）。 下面是demo (Android8.0)中的log： 12345678910111213141516171819202122232425//进入MainActivity2019-06-03 18:29:51.455 9831-9831/com.example.jetpackdemo D/MainActivity_LocationM: onCreate2019-06-03 18:29:51.487 9831-9831/com.example.jetpackdemo D/LocationM: create-CREATED2019-06-03 18:29:51.488 9831-9831/com.example.jetpackdemo D/MainActivity_LocationM: onStart2019-06-03 18:29:51.489 9831-9831/com.example.jetpackdemo D/LocationM: start-STARTED2019-06-03 18:29:51.493 9831-9831/com.example.jetpackdemo D/MainActivity_LocationM: onResume2019-06-03 18:29:51.494 9831-9831/com.example.jetpackdemo D/LocationM: resume-RESUMED//按home键/进入其他页面/按电源键/横竖屏切换（即app短暂进入后台）2019-06-03 18:29:56.099 9831-9831/com.example.jetpackdemo D/LocationM: pause-STARTED2019-06-03 18:29:56.100 9831-9831/com.example.jetpackdemo D/MainActivity_LocationM: onPause2019-06-03 18:29:56.522 9831-9831/com.example.jetpackdemo D/MainActivity_LocationM: onSaveInstanceState2019-06-03 18:29:56.523 9831-9831/com.example.jetpackdemo D/LocationM: stop-CREATED2019-06-03 18:29:56.524 9831-9831/com.example.jetpackdemo D/MainActivity_LocationM: onStop//重新进入MainActivity2019-06-03 18:30:07.496 9831-9831/com.example.jetpackdemo D/MainActivity_LocationM: onStart2019-06-03 18:30:07.497 9831-9831/com.example.jetpackdemo D/LocationM: start-STARTED2019-06-03 18:30:07.497 9831-9831/com.example.jetpackdemo D/MainActivity_LocationM: onResume2019-06-03 18:30:07.500 9831-9831/com.example.jetpackdemo D/LocationM: resume-RESUMED//MainActivity销毁2019-06-04 09:42:24.156 13677-13677/com.example.jetpackdemo D/LocationM: pause-STARTED2019-06-04 09:42:24.158 13677-13677/com.example.jetpackdemo D/MainActivity_LocationM: onPause2019-06-04 09:42:24.638 13677-13677/com.example.jetpackdemo D/LocationM: stop-CREATED2019-06-04 09:42:24.638 13677-13677/com.example.jetpackdemo D/MainActivity_LocationM: onStop2019-06-04 09:42:24.646 13677-13677/com.example.jetpackdemo D/LocationM: destroy-DESTROYED2019-06-04 09:42:24.647 13677-13677/com.example.jetpackdemo D/MainActivity_LocationM: onDestroy 如何理解State?官方的图解如下: 为什么State只有5个？分别为INITIALIZED、DESTROYED、CREATED、STARTED、RESUMED，这里我参考了 这个博客 （非常感谢），其实这5个状态并不像字面上的意思。 生命周期状态为RESUMED时表示，当前activity 是在前台，并且可交互也就onResume()执行后。 生命周期状态为STARTED时，表示当前activity处于可见但是不可交互，也就是onStart()方法刚执行完或者onPause()方法刚执行完的状态。 生命周期状态为CREATED，表示onCreate()方法刚刚执行完或者onStop()方法刚刚执行完，也就是当前activity不在前台，但是也没有处于销毁状态。 生命周期状态为DESTORYED,表示当前Activity还不存在，没有被创建或者已经销毁，我们通常考虑比较多的就是，onDestory()方法执行后，当前Activity已经销毁。 生命周期状态为INITIALIZED，表示初始状态。 所以，如果我们要保证在Activity/Fragment的有效生命周期内进行的操作，必须判断，当前lifecycle的状态是否至少是CREATED状态，避免Activity或者fragment销毁了以后，回调或者网络请求才回来，此时做一些操作会导致异常。代码如下 123if (lifecycle.currentState.isAtLeast(Lifecycle.State.STARTED)) &#123; // do something 保证数据回调回来，当前activity是存在的，也就是State必须为STARTED、RESUMED，Activity此时的状态应该为onStart、onResume、onPause。 &#125; Activity如何实现LifecycleAppcompatActivity默认实现了LifecycleOwner，但是在开发当中一些第三方库使用了Activity，有时候我们也需要实现Lifecycle的功能。代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.example.jetpackdemoimport android.app.Activityimport android.os.Bundleimport androidx.lifecycle.Lifecycleimport androidx.lifecycle.LifecycleOwnerimport androidx.lifecycle.LifecycleRegistryopen class LifeOwnerActivity: Activity(),LifecycleOwner &#123; private val register:LifecycleRegistry = LifecycleRegistry(this) override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) register.currentState = Lifecycle.State.CREATED &#125; override fun getLifecycle(): Lifecycle &#123; return register &#125; override fun onStart() &#123; super.onStart() register.currentState = Lifecycle.State.STARTED &#125; override fun onResume() &#123; super.onResume() register.currentState = Lifecycle.State.RESUMED &#125; override fun onPause() &#123; super.onPause() register.currentState = Lifecycle.State.STARTED &#125; override fun onSaveInstanceState(outState: Bundle?) &#123; super.onSaveInstanceState(outState) register.currentState = Lifecycle.State.CREATED &#125; override fun onStop() &#123; super.onStop() register.currentState = Lifecycle.State.CREATED &#125; override fun onDestroy() &#123; super.onDestroy() register.currentState = Lifecycle.State.DESTROYED &#125; &#125; 本篇博客历时1.5天。]]></content>
      <categories>
        <category>Jetpack</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Jetpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo在Windows下的安装及配置]]></title>
    <url>%2F2019%2F05%2F31%2FHexo%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[安装Git下载git-for-windows ，然后一步一步安装。 安装Node下载node ，然后一步一步安装。 安装Hexo1npm install hexo-cli -g Hexo的初始化123hexo init blogcd blognpm install Hexo的本地测试1hexo s Hexo部署首先在你的github新建一个仓库，名字必须为仓库名.github.io。打开blog根目录下的_config.yml文件，加入或修改成以下配置 1234deploy:type: gitrepo: git@github.com:仓库名/仓库名.github.io.gitbranch: master]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo、Hugo、Jekyll、Ghost的比较]]></title>
    <url>%2F2019%2F05%2F28%2FHexo%E3%80%81Hugo%E3%80%81%20Jekyll%E3%80%81%20Ghost%E5%AF%B9%E6%AF%94%2F</url>
    <content type="text"><![CDATA[Hexo、Hugo、 Jekyll、 Ghost都是生成静态网站的框架。我们先来比较一下：（Github上4个框架的数据来自2019年5月28号） Github star数量 issues(open) issues(close) 语言 多语言 收费 Hexo 26.6k 196 2934 JavaScript 支持 不收 Hugo 35.4k 324 3367 Go 不确定 不收 Jekyll 37.8k 196 1934 Ruby 不确定 不收 Ghost 30.0k 82 5310 JavaScript 不确定 收 从表格可以看出（综合Github star和issues来看） 最活跃的框架是Ghost，没错，因为Ghost是收费的。对于一个只想玩玩的个人开发者来说，我并不建议使用Ghost来搭建个人博客。 Jekyll最受欢迎，并且免费。]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>静态页面生成器</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[欢迎使用Hexo]]></title>
    <url>%2F2019%2F05%2F28%2FHexo%E6%AC%A2%E8%BF%8E%E9%A1%B5%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[欢迎来到 Hexo！ 你可以在 Hexo文档 中获取更多信息。 如果你在使用Hexo过程中遇到任何问题，你可以在故障排除寻找答案，或者你可以在 GitHub寻找答案。 快速开始新建一篇博客1$ hexo new "My New Post" 更多信息请查看: writing 在本地服务中运行1$ hexo server 更多信息请查看: server 生成静态文件1$ hexo generate 更多信息请查看: generating 部署到远程网站1$ hexo deploy 更多信息请查看: deployment]]></content>
  </entry>
</search>
